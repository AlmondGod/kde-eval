import numpy as np
import matplotlib as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt
from scipy.special import erf as erf
from functools import partial as partial
import sys
import numpy as np
from scipy.spatial.distance import pdist, squareform
import math
import random
import heapq



def gaussian_kernel(x, sigma=1.0):
    return np.exp(-0.5 * (x)**2)

def student_kernel(x, sigma=1.0):
    return 1/((x)**2+1)


datasets = {
	'covtype': [54, 581012, 10000, 2.2499],
	'shuttle': [9, 43500, 43500, 0.621882],

}

kernel_data = np.loadtxt("testing_askit.data", delimiter=',', skiprows=0)
test_data = np.loadtxt("testing_askit_query.data", delimiter=',', skiprows=0)
a = kernel_data[:, 1:]
b = test_data[:, 1:]
epsilon = 0.2
delta = 0.1


 


first_two_rows = b[0:1000]
kernel_sums = []
kernel_sums2 = []

for i, row in enumerate(first_two_rows):
    if i % 100 == 0:
        print(i)

    kernel_sumGauss = 0
    kernel_sumStudent = 0
    diff_heap = []
    for j in a:
        diff1 = j - row
        diff = np.linalg.norm(diff1)
        if len(diff_heap) < 10000:
            heapq.heappush(diff_heap, -diff)  # Use negative to simulate max-heap with min-heap
        else:
            if -diff > diff_heap[0]:  # Compare with negative to handle max-heap simulation
                heapq.heapreplace(diff_heap, -diff)
    
    # To get the k smallest distances, negate again
    k_nearest_neighbors = [-d for d in diff_heap]
    k_nearest_neighbors.sort()
        

  
    
    kernel_sums.append(k_nearest_neighbors)
print(kernel_sums)
   

output_file = "kernel_sums_output_random_testing_knn10000.txt"
with open(output_file, 'w') as f:
    for kernel_sum in kernel_sums:
        f.write(str(kernel_sum) + '\n')
# output_file1 = "student_sums_output_random.txt"
# with open(output_file1, 'w') as f:
#     for kernel_sum2 in kernel_sums2:
#         f.write(str(kernel_sum2) + '\n')

print("Kernel sums saved to:", output_file)